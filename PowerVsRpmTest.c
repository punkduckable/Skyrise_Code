#pragma config(Sensor, dgtl1,  R_Drive_Encoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  L_Drive_Encoder, sensorQuadEncoder)
#pragma config(Motor,  port1,           Front_R_Drive, tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           Back_R_Drive,  tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           Back_L_Drive,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          Front_L_Drive, tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define SIZE 128
#define UPDATE_TIME 500

typedef signed char Byte;
typedef unsigned char uByte;

// Protopes
void ArrayGen(void);
void Print_Array(int *Ar);
	uByte Num_Lines = SIZE/10;             // Integer division!

// Global arrays
int Rpm[SIZE];	// used to store rpm data
int PowerArray[SIZE]; // Used to store power array

void ArrayGen(void) {
	uByte j,k;
	int Max = Rpm[0];

	// Find the maximum of the rpm array
	for(j = 0; j < SIZE; j++) {
		if (Rpm[j] > Max) {
			Max = Rpm[j];
		} // if (Ar[j] > Max)
	} // for(j = 0; j < SIZE; j++)

	// Normalize so that maximum value of rpm array has a value of 127
	for(j = 0; j < SIZE; j++) {
		Rpm[j] = (int)(127.0*(float)Rpm[j]/(float)Max);
	}	// for(j = 0; j < SIZE; j++)

	// Print out the normalized RPM array.
	Print_Array(Rpm);

	/* Now, create the new mapping. To do this, we want to correspond a joystick position of n
	   to n/127 of the maximum speed. To do this, for each j, we search through the NormalizedArray
	   until we find a value that is greater than or equal to j . We then store the index of this
	   value in our Power array. This way, when the jth index of the power array will cause the
	   robot to roughly drive at j/127 of the maximum speed.
	*/
	for(j = 0; j < SIZE; j++) {
		for(k = 0; k < SIZE; k++) {
			if(Rpm[k] >= (int)j) {
				PowerArray[j] = k;
				break;
			} // if(NormalizedArray[k] >= j)
		}// for(k = 0; k < SIZE; k++)
	}//	for(j = 0; j < SIZE; j++)

	// Now the power array is generated, print it out.
	Print_Array(PowerArray);
} // void ArrayGen(int *Ar)

void Print_Array(int *Ar) {
	uByte j,k;

	writeDebugStream("\n{\n ");

	for(j = 0; j < Num_Lines; j++) {
		for(k = 0; k < 10; k++) {
			writeDebugStream("%3i, ",Ar[(10*j+k)]);
		} // for(k = 1; j <= 10; j++)
		writeDebugStreamLine("");
	} // for(j = 0; j < (int)(SIZE/10.0); j++)

	for (k = (Num_Lines)*10; k < SIZE; k++) {
		writeDebugStream("%3i, ", Ar[k]);
	} // for(k = (j+1)*10; k < SIZE; k++)
	writeDebugStreamLine("\n};");
} // void Print_Array(int *Ar) {

task main(){
	uByte j = 0;
	//writeDebugStreamLine("[");
	for(j = 0; j < SIZE; j++) {
		SensorValue[R_Drive_Encoder] = 0;
		SensorValue[L_Drive_Encoder] = 0;

		motor[Back_L_Drive]= -j;
		motor[Back_R_Drive]=j;
		motor[Front_L_Drive] = -j;
		motor[Front_R_Drive] = j;

		wait1Msec(UPDATE_TIME);

		Rpm[j] = abs(SensorValue[R_Drive_Encoder] - SensorValue[L_Drive_Encoder])*(500./(UPDATE_TIME*3.));

		//writeDebugStreamLine("%i;",abs(SensorValue[Encode]*((float)1/(float)3)));
		// divide by 360 to get rotations per UPDATE_TIME ms. We then , multiply this
		// number by (60*1000/UPDATE_TIME) to convert the time unit from UPDATE_TIME ms
		// to minutes. This gives us the robot's velocity in RPM.

		continue;
	} // for(i = 1; i <= 127; i++)
	//writeDebugStreamLine("];");

	ArrayGen();

		motor[Back_L_Drive]=0;
		motor[Back_R_Drive]=0;
		motor[Front_L_Drive] = 0;
		motor[Front_R_Drive] = 0;
} // task main()
