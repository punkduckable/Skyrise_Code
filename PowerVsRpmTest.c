#pragma config(Sensor, dgtl1,  Encode,         sensorQuadEncoder)
#pragma config(Motor,  port1,           Front_R_Drive,    tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           Back_R_Drive,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           Back_L_Drive,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          Front_L_Drive,     tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define SIZE 128

// Protopes
void ArrayGen(void);

// Global arrays
int Rpm[SIZE];	// used to store rpm data
int PowerArray[SIZE]; // Used to store power array

void ArrayGen(void) {
	int j,k;
	int Max = Rpm[0];

	// Find the maximum of the rpm array
	for(j = 0; j < SIZE; j++) {
		if (Rpm[j] > Max) {
			Max = Rpm[j];
		} // if (Ar[j] > Max)
	} // for(j = 0; j < SIZE; j++)

	// Normalize so that maximum value of rpm array has a value of 127
	for(j = 0; j < SIZE; j++) {
		Rpm[j] = (int)(127.0*(float)Rpm[j]/(float)Max);
	}	// for(j = 0; j < SIZE; j++)

	// Now, create the new mapping. To do this, we want to correspond a joystick position of n
	// to n/127 of the maximum speed. To do this, for each j, we search through the NormalizedArray
	// until we find a value that is greater than or equal to j . We then store the index of this
	// value in our Power array. This way, when the jth index of the power array will cause the
	// robot to roughly drive at j/127 of the maximum speed.
	for(j = 0; j < SIZE; j++) {
		for(k = 0; k < SIZE; k++) {
			if(Rpm[k] >= j) {
				PowerArray[j] = k;
				break;
			} // if(NormalizedArray[k] >= j)
		}// for(k = 0; k < SIZE; k++)
	}//	for(j = 0; j < SIZE; j++)

	// Now the power array is generated, print it out.
	writeDebugStream("{ ");
	int NumLines = SIZE/10;

	for(j = 0; j < NumLines; j++) {
		for(k = 0; k < 10; k++) {
			writeDebugStream("%i, ",PowerArray[(10*j+k)]);
		} // for(k = 1; j <= 10; j++)
		writeDebugStreamLine("");
	} // for(j = 0; j < (int)(SIZE/10.0); j++)

	for (k = (NumLines)*10; k < SIZE-1; k++) {
		writeDebugStream("%i, ", PowerArray[k]);
	} // for(k = (j+1)*10; k < SIZE; k++)
	writeDebugStreamLine("%i }",PowerArray[SIZE-1]);

} // void ArrayGen(int *Ar)

task main(){
	int j = 0;
	//writeDebugStreamLine("[");
	for(j = 0; j <= 127; j++) {
		SensorValue[Encode] = 0;
		motor[Back_L_Drive]=j;
		motor[Back_R_Drive]=j;
		motor[Front_L_Drive] = j;
		motor[Front_R_Drive] = j;
		wait1Msec(100);

		Rpm[j] = abs(SensorValue[Encode]*(15./9.));

		//writeDebugStreamLine("%i;",abs(SensorValue[Encode]*((float)1/(float)3)));
		// divide by 360 to get rotations per .10 seconds. We then , multiply this
		// number by 600 (.15s/1min). This gives us the robot's velocity in RPM.
		continue;
	} // for(i = 1; i <= 127; i++)
	//writeDebugStreamLine("];");

	ArrayGen();

		motor[Back_L_Drive]=0;
		motor[Back_R_Drive]=0;
		motor[Front_L_Drive] = 0;
		motor[Front_R_Drive] = 0;
} // task main()
